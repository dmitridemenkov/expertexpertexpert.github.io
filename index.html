<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8">
    <title>Экспертдиагностика — техническое диагностирование ВДГО</title>
	<link href="img/favicon.png" rel="shortcut icon" type="image/vnd.microsoft.icon" />
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	<link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>

  <div class="container-fluid" id="contact">
  	<div class="row">
  		меню
  	</div>
  </div>

   <div class="container-fluid" id="img">
  	<div class="row">
  		меню
  	</div>
  </div>

	<nav class="navbar sticky-top navbar-expand-lg navbar-light bg-white" id="menu">
  <a class="navbar-brand" href="#" id="navbarlogo"><img src="img/logo-menu.png" style="height: 20px;"></a>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse justify-content-center" id="navbarSupportedContent">
    <ul class="navbar-nav nav-pills nav-fill">
	  <li class="nav-item">
        <a class="nav-link" href="index.html">ГЛАВНАЯ</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="#">МЕТОДЫ ДИАГНОСТИКИ</a>
      </li>

	  <li class="nav-item">
        <a class="nav-link" href="#">ПРЕИМУЩЕСТВА</a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="#">ПОСЛЕДСТВИЯ</a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="#">ДОКУМЕНТАЦИЯ</a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="#">КОНТАКТЫ</a>
      </li>

    </ul>

  </div>
</nav>

  <div class="container-fluid" id="block1">
  	<div class="row">
  		КАК СТАТЬ АВТОРОМ
Мегапосты:
Разработка LTE
Путь кодера в ПМ
Ping с юга
Разработка
Администрирование
Дизайн
Менеджмент
Маркетинг
Гиктаймс
Разное

Ostrovski
26 февраля 2012 в 00:00
Много текста про практику работы с PHPUnit/DbUnit
PHP
Доброго времени суток, друзья!
Хочу поделиться опытом по борьбе с PHPUnit/DbUnit в связке с MySQL. Далее небольшая предыстория.

Краткая предыстория

В процессе написания одного веб-приложения возникла необходимость тестировать код на PHP, интенсивно взаимодействующий с БД MySQL. В проекте в качестве фреймворка модульного тестирования использовался порт xUnit — PHPUnit. В результате было принято решение писать тесты для модулей, непосредственно взаимодействующих с базой, подцепив плагин PHPUnit/DbUnit. Дальше я расскажу о тех трудностях, которые возникли при написании тестов и о том, каким способом я их преодолел. В ответ же хотелось бы получить комментарии знающих людей относительно корректности моих решений.

Как работает DbUnit

Подпункт предназначен для тех, кто не знаком с методикой тестирования с использованием PHPUnit и/или DbUnit. Кому не интересно, смело можно переходить к следующему.

Далее по тексту:
тестовый класс — класс, содержащий код модульных тестов, наследник любой из реализаций PHPUnit::TestCase;
тестируемый класс — класс, который необходимо протестировать.
Так как подпункт для начинающих, то для начала будет рассмотрена процедура модульного тестирования обычных классов PHP, а потом описаны отличия при тестировании кода, взаимодействующего с БД.

Тестирование обычных классов PHP

Чтобы протестировать класс, написанный на PHP, с использованием фреймворка PHPUnit, необходимо создать тестовый класс, расширяющий базовый класс PHPUnit_Framework_TestCase. Затем создать в этом классе публичные методы, начинающиеся со слова test (если создать метод, который будет называться по-другому, он не будет автоматически вызван при прогоне тестов), и поместить в них код, выполняющий действия с объектами тестируемого класса и проверяющий результат. На этом можно закончить и скормить полученный класс phpunit, который, в свою очередь, последовательно вызовет все тестовые методы и любезно предоставит отчет об их работе. Однако в большинстве случаев в каждом из тестовых методов будет повторяющийся код, подготавливающий систему для работы с тестируемым объектом. Для того, чтобы избежать дублирования кода, в классе PHPUnit_Framework_TestCase созданы защищенные методы setUp и tearDown, имеющие пустую реализацию. Эти методы вызываются перед и после запуска очередного тестового метода соответственно и служат для подготовки системы к выполнению тестовых действий и очистки ее после завершения каждого теста. В тестовом классе, расширяющем PHPUnit_Framework_TestCase, можно переопределить эти методы и поместить повторяющийся ранее в каждом тестовом методе код в них. В результате последовательность вызова методов при прогонке тестов будет следующая:
setUp()       {/* Установили систему в нужное состояние */}
testMethod1() {/* протестировали метод 1 класса */}
tearDown()    {/* Очистили систему */}
setUp()       {/* Установили систему в нужное состояние */}
testMethod2() {/* протестировали метод 2 класса */}
tearDown()    {/* Очистили систему */}
…
setUp()       {/* Установили систему в нужное состояние */}
testMethodN() {/* протестировали метод N класса */}
tearDown()    {/* Очистили систему */}

Тестирование кода PHP, взаимодействующего с БД

Процесс написания тестов для кода, взаимодействующего с БД, практически не отличается от процедуры тестирования обычных классов PHP. Сначала необходимо создать тестовый класс, наследующий PHPUnit_Extensions_Database_TestCase (класс PHPUnit_Extensions_Database_TestCase сам при этом наследует PHPUnit_Framework_TestCase), который будет содержать тесты для методов тестируемого класса. Затем создать тестовые методы, начинающиеся с префикса test, а потом скормить этот код phpunit с указанием имени тестового класса. Отличия заключаются лишь в том, что в тестовом классе обязательно необходимо реализовать два публичных метода — getConnection() и getDataSet(). Первый метод необходим для того, чтобы научить DbUnit работать с БД (придется использовать PDO), а второй для того, чтобы сообщить фреймворку, в какое состояние переводить базу данных перед выполнением очередного теста. Под DataSet в терминологии DbUnit понимается набор из одной или более таблиц.

Как говорилось выше, перед выполнением очередного теста (представленного методом в тестовом классе), PHPUnit вызывает специальный метод setUp(), чтобы сэмулировать среду выполнения для объекта тестируемого класса. В случае DbUnit реализация по умолчанию метода setUp() уже не пустая. Если говорить в общих чертах, то внутри метода setUp() будет создан некий объект databaseTester, который, используя определенный нами метод getConnection(), переведет базу в состояние, представленное набором таблиц (DataSet`ом), получаемым при вызове метода getDataSet(). Если вы были внимательны, то реализация метода getDataSet() также должна предоставляться тестовым классом, т.е. нами. В результате получим похожую последовательность вызовов
setUp()       {/* Установили БД в соответствии с данными, получаемыми от
                  метода getDataSet() */}
testMethod1() {/* протестировали метод 1 класса */}
tearDown()    {/* Очистили систему */}
setUp()       {/* Установили БД в соответствии с данными, получаемыми от
                  метода getDataSet() */}
testMethod2() {/* протестировали метод 2 класса */}
tearDown()    {/* Очистили систему */}
…
setUp()       {/* Установили БД в соответствии с данными, получаемыми от
                  метода getDataSet() */}
testMethodN() {/* протестировали метод N класса */}
tearDown()    {/* Очистили систему */}

Маленькие неприятности

Оперативная обстановка: База данных, используемая в проекте, имеет несколько десятков таблиц, движок MySQL InnoDB. Механизм внешних ключей активно используется с целью поддержания согласованности данных на уровне самой БД.

1. Инициализация базы

Первая неприятность, которая начала омрачать мне процесс тестирования — инициализация базы данных созданными мной наборами таблиц.

DbUnit позволяет создавать DataSet`ы, получая данные из различных источников:
Flat Xml — такой простенький способ описание состояния БД в xml-файле, рассчитанный преимущественно на ручное формирование файла.
Xml — полноценный формат задания состояния, намного больше букаф, но и более широкие возможности (можно задавать null-значения, более точно описывать структуру БД и пр.).
MySQL Xml — разновидность предыдущего формата, любезно предоставленная разработчиками DbUnit, позволяющая создавать объект DataSet на основании экспорта данных БД утилитой mysqldump.
Создание объекта DataSet по текущему состоянию БД.

Каждый из вышеперечисленных способов создания наборов таблиц реализуется отдельным методом класса PHPUnit_Extensions_Database_TestCase.

Я избрал себе в помощники mysqldump и ринулся в атаку: сформировал нужное состояние базы, выгрузил его в xml и в реализации getDataSet() написал что-то вроде:
public function getDataSet() {
    return $this->createMySQLXMLDataSet('db_init.xml');  //имя файла, полученного mysqldump.
}


… и решил прогнать первый тест. Однако, тут же получил исключение, в котором недвусмысленно говорилось о том, что база данных не может быть приведена в заданное состояние из-за наличия в ней ограничений по внешним ключам.

Несколько минут копания в исходниках DbUnit показали, что в методе PHPUnit_Extensions_Database_TestCase::setUp() установка базы в состояние в соответствии с указанным мной DataSet`ом, осуществляется при помощи операции PHPUnit_Extensions_Database_Operation_Factory::CLEAN_INSERT. Операция CLEAN_INSERT в свою очередь представляет собой порождаемую фабрикой макрокоманду, включающую в себя две операции: PHPUnit_Extensions_Database_Operation_Factory::TRUNCATE и PHPUnit_Extensions_Database_Operation_Factory::INSERT. Очевидно, что тут все стало на свои места — не возможно сделать TRUNCATE для базы, у которой имеются активные ограничения по внешним ключам FOREIGN KEY.

Нужно решать. Пути два — либо временно отключить FOREIGN KEY во время тестирования (темный путь), либо использовать новую команду PHPUnit_Extensions_Database_Operation_Factory::DELETE_ALL, обнаруженную во время курения исходников DbUnit (светлый, но более длинный путь). Через минуту темная сторона во мне пересилила, и я решил пойти более простым путем — отключить ограничения целостности по внешним ключам во время создания подключения. Благо код создания все равно был написан мной в реализации метода getConnection().

Типовая реализация getConnection() выглядит примерно так:
public function getConnection() {
    if (is_null($this->m_oConn)) {
        $oPdo = new PDO('mysql:dbname=db1;host=localhost', 'root', 'qwerty');
        $this->m_oConn = $this->createDefaultDBConnection($oPdo, 'db1');
    }

    return $this->m_oConn;
}

$m_oConn — это переменная-член тестового класса, которая представляет собой некоторую обертку вокруг PDO. А если быть точным, то это экземпляр класса PHPUnit_Extensions_Database_DB_DefaultDatabaseConnection. Добавив сразу после создания объекта PDO строку $oPdo->exec('SET foreign_key_checks = 0') я на какое-то время решил проблему с инициализацией.

Собственно, как и следовало ожидать, через некоторое время я напоролся на грабли с несогласованностью данных в базе и пришлось возвращаться на светлый путь, а именно — отказаться от отключения внешних ключей и заменить TRUNCATE на DELETE_ALL.

Очередной просмотр исходников показал, что копать нужно в сторону реализации PHPUnit_Extensions_Database_TestCase::setUp(). Вот ее код:
protected function setUp() {
    parent::setUp(); //вызов PHPUnit_Framework_TestCase::setUp() - пустая реализация

    $this->databaseTester = NULL;

    $this->getDatabaseTester()->setSetUpOperation($this->getSetUpOperation());
    $this->getDatabaseTester()->setDataSet($this->getDataSet());
    $this->getDatabaseTester()->onSetUp();
}


и вот метод getSetUpOperation():
protected function getSetUpOperation() {
    return PHPUnit_Extensions_Database_Operation_Factory::CLEAN_INSERT();
}


Переопределив в своем тестовом классе метод getSetUpOperation() на:
protected function getSetUpOperation() {
    return PHPUnit_Extensions_Database_Operation_Factory::INSERT();
}

я избавился от TRUNCATE, но добавил себе необходимость реализации очистки базы данных. Так как наша база содержит несколько представлений, то бездумный вызов PHPUnit_Extensions_Database_Operation_Factory::DELETE_ALL() для DataSet`а из всех таблиц базы ни к чему хорошему не привел бы. К тому же я посчитал, что функциональность очистки базы может быть достаточно полезной не только в момент инициализации теста, поэтому решил оформить ее в виде самостоятельного метода:
protected function clearDb() {
    $aTableNames = $this->getConnection()->createDataSet()->getTableNames();
    foreach ($aTableNames as $i => $sTableName) {
        if (false === strpos($sTableName, 'view_'))
            continue;
        unset($aTableNames[$i]);
    }
    $aTableNames = array_values($aTableNames);

    $op = \PHPUnit_Extensions_Database_Operation_Factory::DELETE_ALL();
    $op->execute($this->getConnection(), $this->getConnection()->createDataSet($aTableNames));
} 

В коде делается допущение, что все представления, существующие в базе начинаются с префикса view_.
Осталось только переопределить метода setUp(), чтобы он самостоятельно очищал базу перед тем, как отдавать ее на заполнение данными databaseTester`у.
protected function setUp() {
    $this->clearDb();
    parent::setUp();
}


2. Сравнение наборов таблиц

Следующая проблема возникла при попытке сравнения двух DataSet`ов — одного полученного непосредственно из базы (сформированного в результате выполнения тестируемого кода), а другого — созданного заранее руками и представляющего желаемый результат.

Текущее состояние базы можно получить следующим способом:
$oActualDataSet = $this->getConnection()->createDataSet();


Увидев в манах метод PHPUnit_Extensions_Database_TestCase::assertDataSetsEqual, сравнивающий два набора таблиц я очень обрадовался. Как оказалось рановато. Результаты сравнения оказались весьма неожиданными. Два идентичных на вид набора таблиц при сравнении вызывали падение assert`а.

Отладчик в свою очередь показал, что беда в DataSet`е, получаемом из базы. Видимо в целях оптимизации, при вызове $this->getConnection()->createDataSet() в тестовом классе, происходит лишь частичная загрузка набора таблиц, а если быть точным — только метаданные DataSet`а (имя базы и еще какая-то шелуха).

Исходный код PHPUnit_Extensions_Database_TestCase::assertDataSetsEqual следующий:
public static function assertDataSetsEqual(PHPUnit_Extensions_Database_DataSet_IDataSet $expected, PHPUnit_Extensions_Database_DataSet_IDataSet $actual, $message = '')
{
    $constraint = new PHPUnit_Extensions_Database_Constraint_DataSetIsEqual($expected);

    self::assertThat($actual, $constraint, $message);
}


Если раскручивать цепочку вызовов дальше, то после нескольких делегирований непосредственно операции сравнения дело дойдет до PHPUnit_Extensions_Database_DataSet_AbstractTable::matches(PHPUnit_Extensions_Database_DataSet_ITable $other), в котором будут сравниваться две таблицы. В этом методе при сравнении таблиц данные в них будут в обязательном порядке затянуты из базы. Но это если дело дойдет до этого метода. Потому что прежде чем сравнивать таблицы двух DataSet`ов между собой, производится сравнения DataSet`ов. В итоге assert в каком-то месте не проходит. Этот баг есть в issues PHPUnit/DbUnit на github, ему уже несколько месяцев.

В ожидании исправления этой ошибки я быстренько накидал метод сравнения наборов таблиц. Не совсем в духе DbUnit, где все сделано универсальной последовательностью вызовов evaluate -> matches конкретных реализаций сравниваемых объектов, но зато рабочий:
public function compareDataSets(PHPUnit_Extensions_Database_DataSet_IDataSet $expected,
                                    PHPUnit_Extensions_Database_DataSet_IDataSet $actual,
                                    $message = '') {
    $aExpectedNames = $expected->getTableNames();
    $aActualNames   = $actual->getTableNames();

    sort($aActualNames);
    sort($aExpectedNames);

    $this->assertEquals($aExpectedNames, $aActualNames, $message);

    foreach ($aActualNames as $sTableName) {
        $atable = $actual->getTable($sTableName);
        $etable = $expected->getTable($sTableName);

        if (0 == $atable->getRowCount()) {
            $this->assertEquals(0, $etable->getRowCount(), $message);
        } else {
            $this->assertTablesEqual($etable, $atable, $message);
        }
    }
}


Заключение

Поведение DbUnit, описанное в статье, было получено при использовании DbUnit 1.1.2, PHPUnit 3.6.10 и MySQL 5.1. В результате добавления всех вышеописанных костылей был создан базовый класс, расширяющий PHPUnit_Extensions_Database_TestCase и содержащий в себе все эти методы. Остальные тестовые классы проекта, работающие с базой, наследуются от этого базового класса.

Перефразирую одного хорошего человека — дратьсятестировать я не умею, но очень люблю. Так что хотелось бы услышать комментарии по поводу представленных в статье способов.
Теги:
unit test
php
phpunit
dbunit
модульное тестирование
бд
mysql
костыль
суббота

Реклама
ПОХОЖИЕ ПУБЛИКАЦИИ
Модульное тестирование интерфейсов в Headless Chrome. Лекция Яндекса
11,1k
13
Модульное тестирование для приложений на платформе IBM Notes/Domino
1,7k
9
Модульное тестирование Pega приложений: меняем жизнь к лучшему с Ninja
4,6k
0
Разработка для Sailfish OS: Модульное тестирование Qt/C++ под Sailfish OS
3,6k
0
dock: простая библиотека модульного тестирования кода на С++
5,9k
17
Модульное тестирование в современных командах
8,4k
19
Найди общий язык с инопланетным разумом. Тест по JavaScript, C++ и C# Мегатест
+23
18,1k
31

56,0
Карма
0,0
Рейтинг
27
Подписчики
13
Подписки
Ivan Velichko Ostrovski
Software Engineer
Поделиться публикацией
ЧИТАЮТ СЕЙЧАС
Человек, создавший «худшую в мире видеоигру»
72
29,1k
39
21
Персональный компьютер должен был умереть десять лет назад: что произошло вместо этого
11
15,7k
28
132
Тимлид — Таков путь
32
7,4k
52
21
5 символов 1920-х, которые спустя 100 лет поднялись в облака
2
5,3k
6
16
ВАКАНСИИ

PHP-разработчик (backend-программист)
CODE production
Екатеринбург
от 60 000 до 120 000 

PHP-разработчик
АКМЭ сервис
Санкт-Петербург
Можно удаленно
от 100 000 

PHP-разработчик
Drimsim
Можно удаленно
от 120 000 

PHP разработчик
ИМАГ
Москва
Можно удаленно
от 70 000 до 90 000 

PHP разработчик​
Филкос
Саратов
Можно удаленно
от 40 000 до 60 000 
Все вакансии

Реклама
Комментарии 31

k06a
26 февраля 2012 в 00:33
–15
Я думал PHP и TDD не уложатся в голове одного человека, оказывается может))

Ostrovski
26 февраля 2012 в 00:36
+2
Когда на PHP с C++ переезжаешь, еще и не такие метаморфозы могут произойти ;-)
VolCh
26 февраля 2012 в 01:18
+4
Зря вы так… «Имя нам — легион» :) Вроде все более-менее популярные фреймворки разрабатываются с использованием TDD (или покрытием тестами после написания кода, кто их знает). Жаль, что на рынке это не востребовано, что во фрилансе, что в вакансиях * PHP Developer. Про JQuery или ещё что непосредственно к PHP не относящееся обязательно напишут в требованиях, про PHPUnit — ни разу не видел.

Ostrovski
26 февраля 2012 в 01:20
+1
Ничего, нужно верить в светлые времена! Будет и на нашей улице праздник!
VolCh
26 февраля 2012 в 01:25
+2
Быстрее, наверное, рельсы научатся ставиться в продакшене одной строчкой :)

ainu
26 февраля 2012 в 03:26
0
Хероку итак в одну строчку всё делет.
VolCh
26 февраля 2012 в 03:29
0
Ещё бы поднять его локально или на вдске в одну строку :)

k06a
26 февраля 2012 в 01:30
–2
У меня просто такой стереотип PHP'шников.
Автор статьи без сомнения — молодец!

HraKK
26 февраля 2012 в 05:02
+2
Видно не туда смотрите, применение PHP давно выросло за пределы личного сайта Васи Пупкина. Очень многие сейчас уже разрабатывают сложные бизнес или энтерпрайс решения как раз на нем. Первый вопрос который я задаю на собеседовании как раз о Unit тестах, потому что позволяет срезать шелуху сайто-строителей, которых большинство. Но это не значит что все PHP программисты сайто-строители. Сходите к нам на PhpConf(в рамках DevConf) многое почерпнете из того куда и как ушли PHP программисты.
VolCh
26 февраля 2012 в 05:32
+2
Неправильно выразился. Не то, чтобы совсем не видел — видел, вон, например, сбоку висит. Не видел таких, чтобы и TDD требовалось, и я мог претендовать. Я-то как раз сайтостроитель, только по возможности практикую разные *DD. Но не востребовано оно как-то при найме сайтостроителей :( Вот сижу пост пишу о TDD на PHP — последние посты на эту тему показывают, что люди от абстрактных примеров не могут перейти к реальному использованию. Пишу с корыстной целью — чтобы не только в сложных бизнес- или энтерпрайс-решениях был востребован хороший код :)

HraKK
26 февраля 2012 в 12:46
+1
А смысл? Это все равно что из пушки стрелять по мухе. На TDD можно написать CMS/CMF. Но не сайты, потому что, опять же оговорюсь, в большинстве случаев, это лишние затраты на людей для веб-студий. Кстати, именно с написания опен сорс цмс через TDD, я в свое время и познакомился с этой замечательной методологией и перешел на светлую сторону силы (:
VolCh
26 февраля 2012 в 18:06
+2
Как обычно работают сайтостроители — берут CMS/CMF/фреймворк и пишут специфичную логику. И хорошо, если пишут её в рамках идеологии системы, не нарушая её архитектуру. Получается код CMS/CMF/фреймворка тестами покрыт, а специфичный код нет. Сначала код тривиальный и вроде бы тестирование не нужно, но постепенно разрастается, вставляются костыли, антипаттерны и тривиальный код превращается в код, который очень сложно поддерживать.

kokoc
26 февраля 2012 в 00:38
+1
Мое имхо — не стоит заливать/перезаливать всю базу данных из нескольких десятков таблиц перед каждым тестом. Возможно есть смысл не вносить ключи в дамп вообще, и в каждом тесте вливать не всю базу, а только ту таблицу, которая относится к тестируемой сущьности. В таком случае и тесты быстрее отработают и целосность вы тестировать не будете(т.к. задача проверки корректности работы ключей — это задача mysql команды).

Ostrovski
26 февраля 2012 в 00:44
0
Таблицы перед каждым тестом содержат всего по 3-5 записей и заливаются всегда в пустую базу. Ключи я и так отфильтровываю при сравнении датасетов, за исключением некоторых тестов, где именно ключи и интересны.
VolCh
26 февраля 2012 в 01:22
0
Чтоб не заливать всю базу перед каждым тестом, можно (попробовать) заливать неизменяемую часть в методах setUpBeforeClass/tearDownAfterClass, а в setUp/tearDown чистить только нужные таблицы.

Ostrovski
26 февраля 2012 в 01:26
0
Спасибо за наводку! Нужно будет учесть, полезная фишка.

Davert
26 февраля 2012 в 00:41
+4
Вот собственно из-за столь неочевидных методов тестирования БД, я и написал Codeception. В нем тестирование БД проводится всего лишь подключением модуля Db, и указания файла с дампом. При использовании ОРМ в проекте, базу вообще можно не очищать, а выполнять тесты в транзакции, и откатывать их в конце.

Как по мне, то задача тут достаточно проста. А решается в PHPUnit она, как видно даже с этого поста, излишне сложно. И DbUnit это инструмент для усложнения жизни, а не эффективного тестирования. имхо.

Ostrovski
26 февраля 2012 в 00:46
0
Ваш Codeception в моем списке на Workflowy с первой Вашей статьи. Скоро я до него доберусь, выглядит он достаточно заманчиво.

Davert
26 февраля 2012 в 00:58
0
В любом случае, лучше если есть возможность, вообще не заниматься очисткой БД в рамках юнит-тестов. Используйте транзакции. Учитывая, что в MySQL нет вложенных транзакций, то важно, чтобы у вас был какой-то слой абстракции над PDO, который мог бы вести учет транзакций и откатывать только самую последнюю из них.

Ostrovski
26 февраля 2012 в 01:01
0
Но ведь тестирование выполняется не на боевой базе. У нас вообще есть несколько баз с одинаковой структурой — для модульных тестов, для нагрузочных тестов и боевая. Каков в таком случае минус в том, что база очищается каждый раз?

Davert
26 февраля 2012 в 01:04
+1
Один из самых важных критериев для юнит-тестов это скорость выполнения. А очистка базы, скорее всего, будет самой медленной операцией. Например, на MageConf упоминали, что в Magento несколько тысяч юнит-тестов, которые выполняются за одну минуту. Такая скорость достигнута только за счет транзакций. Без них, сами понимаете, время выполнения будет гораздо длиннее.

Ostrovski
26 февраля 2012 в 01:10
0
Да, Вы правы, что для модульных тестов время выполнения очень важно. Хотя в нашем случае ему еще далеко до критической отметки. Нужно будет провести на следующей неделе профилирование, чтобы точно выяснить, какой процент времени занимает именно очистка базы. Просто достаточно удивительно, что в DbUnit этого не учли, если это действительно так. Но возможно, что это не учтено только в порте для PHP.

Davert
26 февраля 2012 в 01:21
–1
Честно, я не очень, разбирался в DbUnit, но скорее всего, для MySQL там хорошего решения нет. Ибо тут необходимы вложенные транзакции или их эмуляция. Эмулировать транзакции можно, если транзакциями занимается не PDO, а некая обертка над ним. Она может следить, является ли эта транзакция последней, и только тогда делать rollback или commit.

Такие вещи реализованы в Doctrine, Doctrine 2 DBAL. И не реализованы, в том же Zend_Db, хотя там достаточно простой патч и висит у них в багтрекере ещё с 2007го. Почему? Непонятно.

Ostrovski
26 февраля 2012 в 01:24
+1
На самом деле, судя по состоянию кода, DbUnit для PHP сейчас еще очень далек от полноценной реализации. И не только для MySQL.

kokoc
26 февраля 2012 в 02:56
+3
Здесь стоит помнить о том, что любые операции по модификации структуры БД в MySQL приводят к автокомиту транзакций. Так что и тесты необходимо будет проектировать соответственно.
VolCh
26 февраля 2012 в 01:43
0
Пробовал работать с DBUnit, быстро разочаровался. Но так как тесты пишу лично для себя (читай — никто их у меня не просит и не требует, тестирую что хочу и как хочу), то быстро пришёл к такому способу написания функциональных/интеграционных тестов (тест с БД никак не может быть юнит-тестом ;) ): создаю мокостабы PDO, mysqli или своей примитивной обёртки над mysql_*) для методов типа $db->query($query) и $db->fetch_assoc($result), проверяющие, что тестируемый метод действительно вызывает, например, сначала $db->query('SELECT * FROM users WHERE group_id = 1'), а потом три раза $db->fetch_assoc(), и возвращающие true(не false), array(...), array(...) и false.
pro100tak
26 февраля 2012 в 05:10
–2
Я пока обхожусь миграциями с версионностью. Также, постоянно в объекте миграций хранится массив данных, которые когда-либо были загружены и т.п. Таким образом убирается хардкод тестовых данных по типу $this->assertEquals($oModel->getName(3), 'Vasya');
Кстати — есть ещё несколько полезных методов, кроме setUp() и tearDown() — setUpBeforeClass() и т.д. Т.е. для всего теста можно загружать неизменяющиеся данные не на этапе подготовки тестов (что будет прекрасной утилизацией процессорного времени, но зря, если какой-либо тест упадёт до использования данных), а при инстанциировании класса теста.
aeryaguzov
26 февраля 2012 в 20:21
+2
ОМГ! Сначала expected, потом actual: $this->assertEquals('Vasya', $oModel->getName(3));
И assertEquals это не хардкод, это так тестировать результат принято:-)
VolCh
26 февраля 2012 в 21:26
0
Не знаю насчёт хардкода:
//...
$user = new User();
$user_name = 'Vasya';

$user->setName($user_name);

$this->assertEquals($user_name, $user->getName());
//...

Имхо так лучше, минимум меньше вероятность допустить ошибку в тесте.
aeryaguzov
26 февраля 2012 в 21:57
+1
смайлик в конце как бы намекает на неверно построенное предложение автором коммента:-)
pro100tak
26 февраля 2012 в 22:48
+1
Я не про assertEquals(). Я говорил вот про что:
class UserTest extends PHPUnit_Framework_TestCase {
    public static function setUpBeforeClass() {
        DB_Migrate::load()->users;
    }

    public function testGetUser() {
        $oUser = new UserModel(1);
        $this->assertEquals(DB_Migrate::get()->users[1]['name'], $oUser->getName(), 'User load failed');
        // Вместо
        // $this->assertEquals('Vasya', $oUser->getName(), 'User load failed');
    }
}

При этом, таблица users будет уже заполнена нужными данными из миграции и при изменении тестового набора данных этот тест упадёт. Не каждый объект снабжён сеттерами и делать из мне не интересно, если я тестирую ЗАГРУЗКУ и ПОДГОТОВКУ данных объекта. Сеттеры тестировать конечно надо, но не в первую очередь. Я не об этом говорил.

В Вашем (и многоуважаемого VoICh) случае 'Vasya' — магическая переменная.
Только полноправные пользователи могут оставлять комментарии. Войдите, пожалуйста.

ЧТО ОБСУЖДАЮТ
Сейчас
Вчера
Неделя
Какие бы у меня возникли проблемы, если бы я боролся за гендерный баланс в ИТ?
33,3k
566
Персональный компьютер должен был умереть десять лет назад: что произошло вместо этого
15,7k
132
Приготовься к введению в России социального рейтинга
59,3k
616
Туториал из руководства по Ember.js. Приложение Super Rentals. Часть 1.1
949
6
Человек, создавший «худшую в мире видеоигру»
29,1k
21
САМОЕ ЧИТАЕМОЕ
Сутки
Неделя
Месяц
Человек, создавший «худшую в мире видеоигру»
+72
29,1k
39
21
Впервые учёные убили спящий вирус герпеса в клетках человека
+36
25,9k
57
30
Посвящается: технологии, которые умерли в 2019 году
+30
30,4k
45
62
Персональный компьютер должен был умереть десять лет назад: что произошло вместо этого
+11
15,7k
28
132
Умный дом с Xiaomi на примере бани
+19
14k
93
69
РЕКОМЕНДУЕМ
Разместить
Промо 
Откуда все берется: подарки для офисных волшебников
Промо 
Умный дом, умная квартира, умный хозяин
Ваш аккаунт
Войти
Регистрация
Разделы
Публикации
Новости
Хабы
Компании
Пользователи
Песочница
Информация
Правила
Помощь
Документация
Соглашение
Конфиденциальность
Услуги
Реклама
Тарифы
Контент
Семинары
Мегапроекты
Если нашли опечатку в посте, выделите ее и нажмите Ctrl+Enter, чтобы сообщить автору.
© 2006 – 2020 «TM»
 Настройка языка
О сайте
Служба поддержки
Мобильная версия

  	</div>
  </div>
  <div class="container-fluid" id="block2">
  	<div class="row">
  		меню
  	</div>
  </div>
  <div class="container-fluid" id="block3">
  	<div class="row">
  		меню
  	</div>
  </div>
   <div class="container-fluid" id="block4">
  	<div class="row">
  		меню
  	</div>
  </div>
   <div class="container-fluid" id="block5">
  	<div class="row">
  		меню
  	</div>
  </div>
  	<div class="row"></div>
  <div class="container-fluid" id="block6">
  	<div class="row">
  		меню
  	</div>
  </div>
  
<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>


  </body>
</html>